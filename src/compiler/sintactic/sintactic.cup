package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;
import compiler.codigo_intermedio.*;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 
    public static CodigoIntermedio codigoIntermedio = new CodigoIntermedio();

    public static ComplexSymbolFactory factory = new ComplexSymbolFactory();

    public int getLine(Symbol cur_token) {
        ComplexSymbol token = (ComplexSymbol) cur_token;
        Location l = token.getLeft();
        return l.getLine();
        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        String mensaje = "Error sintáctico en línea " + getLine(cur_token) +
                     ": se encontró '" + (cur_token.value != null ? cur_token.value : cur_token.sym) + "'";
        ErrorManager.addError(2, mensaje);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        String mensaje = "Error sintáctico no recuperable en línea " + getLine(cur_token) +
                        ": se encontró '" + (cur_token.value != null ? cur_token.value : cur_token.sym) + "'";
        
        ErrorManager.addError(2, mensaje); // 2 indica error sintáctico

        // Detener el análisis sintáctico
        done_parsing();
    }
:}

terminal String ID;
terminal String TYPE;
terminal FLOAT_LITERAL, INT_LITERAL, BOOLEAN_LITERAL;
terminal CONST;
terminal SEMICOLON;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, EQUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA, ARRAY, DEF, RETURN, OP_ARITMETICO, OP_LOGICO, OP_COMPARACION;
terminal IF, ELIF, ELSE, WHILE, REPEAT, UNTIL, DOT, PRINT, INPUT;

non terminal Programa, ProgramaList, Main, Sentencia, DecConstante, Valor;
non terminal DecVar, Asignacion, DecTupla, ListaParametros, DecArray, ListaDimensiones, ListaDimensionesRef;
non terminal DecFun, Bloque, LlamadaFuncion, ListaArgumentos, Referencia;
non terminal Return, Expresion, ListaTupla, If_Sentencia, Elif_Lista, While_Sentencia;
non terminal Repeat_Until, LlamadaArray, LlamadaTupla, Print_Sentencia, Input_Sentencia, ListaExpresiones;

precedence left OP_ARITMETICO;
precedence left OP_LOGICO;
precedence left OP_COMPARACION;

Programa ::= ProgramaList
            ;

ProgramaList ::= DecFun ProgramaList
            | Main
            ;
Main ::= LBRACE Bloque:bloque RBRACE 
            {: SemanticHelper.procesarMain((SBloque) bloque, taulaSim, codigoIntermedio); :}
        | error RBRACE
        ;

Bloque ::= Sentencia:sentencia Bloque:bloque
            {: RESULT = new SBloque((SBloque) bloque, (SBase) sentencia); :}
        | Sentencia:sentencia
            {: RESULT = new SBloque((SBase) sentencia); :}
            ;

Sentencia ::= DecConstante:s SEMICOLON      {: RESULT = s; :}
            | DecVar:s SEMICOLON            {: RESULT = s; :}
            | DecArray:s SEMICOLON          {: RESULT = s; :}
            | DecTupla:s SEMICOLON          {: RESULT = s; :}
            | Asignacion:s SEMICOLON        {: RESULT = s; :}
            | Return:s SEMICOLON            {: RESULT = s; :}
            | If_Sentencia:s                {: RESULT = s; :}
            | While_Sentencia:s             {: RESULT = s; :}
            | Repeat_Until:s                {: RESULT = s; :}
            | Print_Sentencia:s SEMICOLON   {: RESULT = s; :}
            | Input_Sentencia:s SEMICOLON   {: RESULT = s; :}
            | LlamadaFuncion:s SEMICOLON    {: RESULT = s; :}
            | error SEMICOLON
            ;

DecConstante ::= CONST:c TYPE:type ID:id EQUAL Valor:valor 
                    {: RESULT = new SDecConstante(cleft, type, id, (SValor) valor); :}
                ;

DecVar ::= TYPE:type ID:id 
            {: RESULT = new SDecVar(typeleft, type, id); :}
        ;

DecArray ::= ARRAY:a TYPE:type ID:id ListaDimensiones:lista
                {: RESULT = new SDecArray(aleft, type, id, (SListaDimensiones) lista); :}
            ;

DecTupla ::= TUPLA:t ID:id EQUAL LPAREN ListaTupla:lista RPAREN
                {: RESULT = new SDecTupla(tleft, id, (SListaTupla) lista); :}
            ;

ListaTupla ::= ID:id COMMA ListaTupla:lista
                {: RESULT = new SListaTupla((SListaTupla) lista, id); :}
            | ID:id
                {: RESULT = new SListaTupla(id); :}
            ;

ListaDimensiones ::= LBRACKET INT_LITERAL:size RBRACKET ListaDimensiones:lista
                    {: RESULT = new SListaDimensiones(sizeleft, (String) size, (SListaDimensiones) lista); :}
                | LBRACKET INT_LITERAL:size RBRACKET
                    {: RESULT = new SListaDimensiones(sizeleft, (String) size, null); :}
                ;

Asignacion ::= Referencia:r EQUAL Expresion:e
                    {: RESULT = new SAsignacion(rleft, (SReferencia) r, (SExpresion) e); :}
                ;

ListaParametros ::= TYPE:type ID:id COMMA ListaParametros:lista  
                        {: RESULT = new SListaParametros(typeleft, type, id, (SListaParametros) lista); :}
                    | TYPE:type ID:id
                        {: RESULT = new SListaParametros(typeleft, type, id); :}
                    ;

DecFun ::= DEF:d TYPE:type ID:id LPAREN ListaParametros:params RPAREN LBRACE Bloque:bloque RBRACE
                {: SemanticHelper.procesarDecFuncion(dleft, type, id, (SListaParametros) params, (SBloque) bloque, taulaSim, codigoIntermedio); :}
            | error RBRACE 
            ;

Referencia ::= LlamadaArray:r       {: RESULT = new SReferencia((SBase) r); :}
                | LlamadaTupla:r    {: RESULT = new SReferencia((SBase) r); :}
                | LlamadaFuncion:r  {: RESULT = new SReferencia((SBase) r); :}
                | ID:id             {: RESULT = new SReferencia((String) id); :}
                ;

LlamadaFuncion ::= ID:id LPAREN ListaArgumentos:lista RPAREN 
                {: 
                    TipoSubyacente tipoRetorno = SemanticHelper.obtenerTipoFuncion(id, taulaSim);
                    RESULT = new SLlamadaFuncion(idleft, id, (SListaArgumentos) lista, tipoRetorno); 
                :}
                ;
LlamadaArray ::= ID:id ListaDimensionesRef:lista
                    {: RESULT = new SLlamadaArray(idleft, id, (SListaDimensionesRef) lista); :}
                ;

ListaDimensionesRef ::= LBRACKET Expresion:e RBRACKET ListaDimensionesRef:lista
                            {: RESULT = new SListaDimensionesRef(eleft, (SExpresion) e, (SListaDimensionesRef) lista); :}
                        | LBRACKET Expresion:e RBRACKET
                            {: RESULT = new SListaDimensionesRef(eleft, (SExpresion) e, null); :}
                        ;

LlamadaTupla ::= ID:id DOT ID:campo
                    {: RESULT = new SLlamadaTupla(idleft, id, campo); :}
                ;

ListaArgumentos ::= Expresion:e COMMA ListaArgumentos:lista
                    {: RESULT = new SListaArgumentos(listaleft, (SListaArgumentos) lista, (SExpresion) e); :}
                | Expresion:e
                    {: RESULT = new SListaArgumentos(eleft, (SExpresion) e); :}
                ;

If_Sentencia ::= IF:i Expresion:expresion LBRACE Bloque:bloque1 RBRACE Elif_Lista:lista ELSE LBRACE Bloque:bloque2 RBRACE
                    {: RESULT = new SIf(ileft, (SExpresion) expresion, (SBloque) bloque1, (SElif) lista, (SBloque) bloque2); :}
                | IF:i Expresion:expresion LBRACE Bloque:bloque1 RBRACE Elif_Lista:lista
                    {: RESULT = new SIf(ileft, (SExpresion) expresion, (SBloque) bloque1, (SElif) lista, null); :}
                | IF:i Expresion:expresion LBRACE Bloque:bloque1 RBRACE ELSE LBRACE Bloque:bloque2 RBRACE
                    {: RESULT = new SIf(ileft, (SExpresion) expresion, (SBloque) bloque1, null, (SBloque) bloque2); :}
                | IF:i Expresion:expresion LBRACE Bloque:bloque1 RBRACE
                    {: RESULT = new SIf(ileft, (SExpresion) expresion, (SBloque) bloque1, null, null); :}
                ;

Elif_Lista ::= ELIF:e Expresion:expresion LBRACE Bloque:bloque RBRACE Elif_Lista:lista
                    {: RESULT = new SElif(eleft, (SElif) lista, (SExpresion) expresion, (SBloque) bloque); :}
                | ELIF:e Expresion:expresion LBRACE Bloque:bloque RBRACE
                    {: RESULT = new SElif(eleft, (SExpresion) expresion, (SBloque) bloque); :}
                ;

While_Sentencia ::= WHILE:w Expresion:expresion LBRACE Bloque:bloque RBRACE
                    {: RESULT = new SWhile(wleft, (SExpresion) expresion, (SBloque) bloque); :}
                ;

Repeat_Until ::= REPEAT:r LBRACE Bloque:bloque RBRACE UNTIL Expresion:e SEMICOLON
                    {: RESULT = new SRepeatUntil(rleft, (SBloque) bloque, (SExpresion) e); :}
                ;

Print_Sentencia ::= PRINT LPAREN ListaExpresiones:lista RPAREN
                        {: RESULT = new SPrint((SListaExpresiones) lista); :}
                    ;

Input_Sentencia ::= INPUT:i LPAREN ID:id RPAREN
                        {: RESULT = new SInput(ileft, id); :}
                    ;

ListaExpresiones ::= ListaExpresiones:lista COMMA Expresion:e
                        {: RESULT = new SListaExpresiones((SListaExpresiones) lista, (SExpresion) e); :}
                    | Expresion:e
                        {: RESULT = new SListaExpresiones((SExpresion) e); :}
                    ;

Return ::= RETURN:r Expresion:expresion 
            {: RESULT = new SReturn(rleft, (SExpresion) expresion); :}
        | RETURN:r 
            {: RESULT = new SReturn(rleft); :}
        ;

Expresion ::= Expresion:e1 OP_ARITMETICO:op Expresion:e2
                {: RESULT = new SExpresion(e1left, (SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_LOGICO:op Expresion:e2
                {: RESULT = new SExpresion(e1left, (SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_COMPARACION:op Expresion:e2
                {: RESULT = new SExpresion(e1left, (SExpresion) e1, (SExpresion) e2, (String) op); :}
            | LPAREN Expresion:e RPAREN
                {: RESULT = e; :}
            | Valor:valor
                {: RESULT = new SExpresion(valorleft, (SValor) valor); :}
            | Referencia:referencia
                {: RESULT = new SExpresion(referencialeft, (SReferencia) referencia); :}
            ;

Valor ::= INT_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.INT), (String) v); :}
        | BOOLEAN_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.BOOLEAN), Integer.toString((v.equals("true")) ? -1 : 0)); :}
        ;

