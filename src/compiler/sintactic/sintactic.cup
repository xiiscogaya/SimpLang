package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Error sintactic", cur_token);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_error("Error sintactico no recuperable", cur_token);
        done_parsing();
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line " + (s.left + 1));   
                if (s.right >= 0)
                    m.append(", column " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }
:}

terminal String ID;
terminal VALOR;
terminal String STRING_LITERAL;
terminal INT, STRING, BOOL, FLOAT, VOID, BOOLEAN_LITERAL;
terminal CONST, SEMICOLON;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, OP_ASSIGN, EQUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA, ARRAY;

non terminal Programa, ProgramaList, DecList, Main, Sentencia, DecConstante, Valor, Type;
non terminal DecVar, Asignacion, DecTupla, ListaParametros, DecArray, ListaDimensiones;

Programa ::= ProgramaList
            ;

ProgramaList ::= LBRACE Main RBRACE 
                ;

/**
DecList ::= DecFun 
            | DecClass 
            | error RBRACE
            ;
**/

Main ::= Main Sentencia
        | Sentencia
        ;

Sentencia ::= DecConstante 
            | DecVar
            | Asignacion
            | DecTupla
            | DecArray
            ;

DecConstante ::= CONST Type:idType ID:id EQUAL Valor:valor SEMICOLON
                    {: RESULT = SemanticHelper.processConstantDeclaration((SType) idType, id, (SValor) valor, taulaSim); :}
                ;

DecVar ::= Type:idType ID:id EQUAL Valor:valor SEMICOLON
            {: RESULT = SemanticHelper.processVarDeclaration(idType, id, valor, taulaSim); :}
        | Type:idType ID:id SEMICOLON
            {: RESULT = SemanticHelper.processVarDeclaration(idType, id, null, taulaSim); :}
        ;

Asignacion ::= ID:id EQUAL Valor:valor SEMICOLON
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "=", taulaSim); :}
            | ID:id OP_ASSIGN:op Valor:valor SEMICOLON
                {: RESULT = SemanticHelper.processAsignacion(id, valor, (String) op, taulaSim); :}
            ;

DecTupla ::= TUPLA ID:id EQUAL LPAREN ListaParametros:lista RPAREN SEMICOLON
            {: RESULT = SemanticHelper.processTuplaDeclaration(id, (SListaParametros) lista, taulaSim); :}
            ;

ListaParametros ::= ListaParametros:lista COMMA Type:idType Valor:valor
                        {: RESULT = SemanticHelper.procesarListaParametros((SListaParametros) lista, (SType) idType, (SValor) valor); :}
                    | Type:idType Valor:valor
                        {: RESULT = SemanticHelper.procesarListaParametros(null, (SType) idType, (SValor) valor); :}
                    ;

DecArray ::= ARRAY Type:idType ID:id ListaDimensiones:lista SEMICOLON
            {: 
                RESULT = SemanticHelper.crearArrayConDimensiones((SType) idType, (String) id, (SDimension) lista, taulaSim); 
            :}
            ;

ListaDimensiones ::= ListaDimensiones:lista LBRACKET VALOR:size RBRACKET
                    {: 
                        // Añadir la dimensión a la lista de dimensiones acumulada en RESULT
                        RESULT = SemanticHelper.agregarDimension((SDimension) lista, (String) size); 
                    :}
                    | LBRACKET VALOR:size RBRACKET
                    {: 
                        RESULT = SemanticHelper.agregarDimension(null, (String) size);
                    :}
                    ;




Type ::= INT     {: RESULT = new SType(new TipoSubyacente(Tipus.INT)); :}
       | FLOAT   {: RESULT = new SType(new TipoSubyacente(Tipus.FLOAT)); :}
       | BOOL    {: RESULT = new SType(new TipoSubyacente(Tipus.BOOLEAN)); :}
       | STRING  {: RESULT = new SType(new TipoSubyacente(Tipus.STRING)); :}
       ;

Valor ::= VALOR:v
            {: 
                // Detectar si es entero o flotante según la presencia del punto decimal
                if (((String) v).contains(".")) {
                    RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.FLOAT), v);
                } else {
                    RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.INT), v);
                }
            :}
        | STRING_LITERAL:v
            {: RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.STRING), v); :}
        | BOOLEAN_LITERAL:v
            {: RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.BOOLEAN), v); :}
        ;
