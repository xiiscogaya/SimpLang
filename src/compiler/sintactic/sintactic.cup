package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Error sintactic", cur_token);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_error("Error sintactico no recuperable", cur_token);
        done_parsing();
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line " + (s.left + 1));   
                if (s.right >= 0)
                    m.append(", column " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }
:}

terminal String ID;
terminal VALOR;
terminal String STRING_LITERAL;
terminal FLOAT_LITERAL, INT_LITERAL;
terminal INT, STRING, BOOL, FLOAT, VOID, BOOLEAN_LITERAL;
terminal CONST, SEMICOLON;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, OP_ASSIGN, EQUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA, ARRAY, DEF, CLASS, RETURN, OP_ARITMETICO, OP_LOGICO, OP_COMPARACION;

non terminal Programa, ProgramaList, DecList, Main, Sentencia, DecConstante, Valor, Type;
non terminal DecVar, Asignacion, DecTupla, ListaParametros, DecArray, ListaDimensiones;
non terminal DecFun, DecClass, ClassMemberList, ClassMember, Bloque, LlamadaFuncion, ListaArgumentos;
non terminal Return, Expresion;

precedence left OP_ARITMETICO;
precedence left OP_LOGICO;
precedence left OP_COMPARACION;

Programa ::= ProgramaList
            ;

ProgramaList ::= DecList ProgramaList
            | LBRACE Main:main RBRACE 
                {: SemanticHelper.procesarMain((SMain) main, taulaSim); :}
            ;


DecList ::= DecFun 
            | DecClass 
            | error RBRACE
            ;

Main ::= Sentencia:sentencia Main:main
            {: RESULT = new SMain((SMain) main, (SBase) sentencia); :}
        | Sentencia:sentencia
            {: RESULT = new SMain((SBase) sentencia); :}
        ;

Bloque ::= Sentencia:sentencia Bloque:bloque
            {: RESULT = new SBloque((SBloque) bloque, (SBase) sentencia); :}
        | Sentencia:sentencia
            {: RESULT = new SBloque((SBase) sentencia); :}
            ;

Sentencia ::= DecConstante:s SEMICOLON      {: RESULT = s; :}
            | DecVar:s SEMICOLON            {: RESULT = s; :}
            | DecArray:s SEMICOLON          {: RESULT = s; :}
            | Asignacion:s SEMICOLON        {: RESULT = s; :}
            | LlamadaFuncion:s SEMICOLON    {: RESULT = s; :}
            | Return:s SEMICOLON            {: RESULT = s; :}
            ;

DecConstante ::= CONST Type:idType ID:id EQUAL Valor:valor 
                    {: RESULT = new SDecConstante((SType) idType, id, (SValor) valor); :}
                ;

DecVar ::= Type:idType ID:id EQUAL Expresion:e 
            {: RESULT = new SDecVar((SType) idType, id, (SExpresion) e); :}
        | Type:idType ID:id 
            {: RESULT = new SDecVar((SType) idType, id, null); :}
        ;

DecArray ::= ARRAY Type:idType ID:id ListaDimensiones:lista
            {: RESULT = new SDecArray((SType) idType, id, (SListaDimensiones) lista); :}
            ;

ListaDimensiones ::= LBRACKET Valor:size RBRACKET ListaDimensiones:lista
                    {: RESULT = new SListaDimensiones((SValor) size, (SListaDimensiones) lista); :}
                | LBRACKET Valor:size RBRACKET
                    {: RESULT = new SListaDimensiones((SValor) size, null); :}
                ;

Asignacion ::= ID:id EQUAL Expresion:e 
                {: RESULT = new SAsignacion(id, (SExpresion) e); :}
            | ID:id OP_ASSIGN:op Expresion:e 
                {: RESULT = new SAsignacion(id, (SExpresion) e); :}
            ;

ListaParametros ::= ListaParametros:lista COMMA Type:idType ID:id
                        {: RESULT = new SListaParametros((SType) idType, id, (SListaParametros) lista); :}
                    | Type:idType ID:id
                        {: RESULT = new SListaParametros((SType) idType, id); :}
                    ;

DecFun ::= DEF Type:idType ID:id LPAREN ListaParametros:params RPAREN LBRACE Bloque:bloque RBRACE
            {: SemanticHelper.procesarDecFuncion((SType) idType, id, (SListaParametros) params, (SBloque) bloque, taulaSim); :}
            ;

LlamadaFuncion ::= ID:id LPAREN ListaArgumentos:lista RPAREN 
                {: 
                    TipoSubyacente tipoRetorno = SemanticHelper.obtenerTipoFuncion(id, taulaSim);
                    RESULT = new SLlamadaFuncion(id, (SListaArgumentos) lista, tipoRetorno); 
                :}
                ;

ListaArgumentos ::= ListaArgumentos:lista COMMA Expresion:e
                    {: RESULT = new SListaArgumentos((SListaArgumentos) lista, (SExpresion) e); :}
                | Expresion:e
                    {: RESULT = new SListaArgumentos((SExpresion) e); :}
                ;

Return ::= RETURN Expresion:expresion 
            {: RESULT = new SReturn((SExpresion) expresion); :}
        | RETURN 
            {: RESULT = new SReturn(); :}
        ;

Type ::= INT     {: RESULT = new SType(new TipoSubyacente(Tipus.INT)); :}
       | FLOAT   {: RESULT = new SType(new TipoSubyacente(Tipus.FLOAT)); :}
       | BOOL    {: RESULT = new SType(new TipoSubyacente(Tipus.BOOLEAN)); :}
       | STRING  {: RESULT = new SType(new TipoSubyacente(Tipus.STRING)); :}
       | VOID    {: RESULT = new SType(new TipoSubyacente(Tipus.VOID)); :}
       ;

Expresion ::= Expresion:e1 OP_ARITMETICO:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_LOGICO:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_COMPARACION:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | LlamadaFuncion:func
                {: RESULT = new SExpresion((SLlamadaFuncion) func); :}
            | LPAREN Expresion:e RPAREN
                {: RESULT = e; :}
            | Valor:valor
                {: RESULT = new SExpresion((SValor) valor); :}
            | ID:id
                {: RESULT = new SExpresion((String) id); :}
            ;

Valor ::= INT_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.INT), (String) v); :}
        | FLOAT_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.FLOAT), (String) v); :}
        | STRING_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.STRING), (String) v); :}
        | BOOLEAN_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.BOOLEAN), (String) v); :}
        ;

