package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;

import java.io.PrintStream;
import java.util.HashMap;

class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Error sintactic", cur_token);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_error("Error sintactico no recuperable", cur_token);
        done_parsing();
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line " + (s.left + 1));   
                if (s.right >= 0)
                    m.append(", column " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }
:}

terminal String ID;
terminal INT_LITERAL;
terminal FLOAT_LITERAL;
terminal String STRING_LITERAL;
terminal INT, STRING, BOOL, FLOAT, VOID;
terminal CONST, SEMICOLON;
terminal LBRACE, RBRACE, EQUAL, PLUS_IGUAL, MENOS_IGUAL, TIMES_IGUAL, DIVIDE_IGUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA;

non terminal Programa, ProgramaList, DecList, Main, Sentencia, DecConstante, Valor, Type;
non terminal DecVar, Asignacion, DecTupla, TipoLista, ValorLista;

Programa ::= ProgramaList
            ;

ProgramaList ::= LBRACE Main RBRACE 
                ;

/**
DecList ::= DecFun 
            | DecClass 
            | error RBRACE
            ;
**/

Main ::= Main Sentencia
        | Sentencia
        ;

Sentencia ::= DecConstante 
            | DecVar
            | Asignacion
            | DecTupla
            ;

DecConstante ::= CONST Type:idType ID:id EQUAL Valor:valor SEMICOLON
                    {: RESULT = SemanticHelper.processConstantDeclaration(idType, id, valor, taulaSim); :}
                ;

DecVar ::= Type:idType ID:id EQUAL Valor:valor SEMICOLON
            {: RESULT = SemanticHelper.processVarDeclaration(idType, id, valor, taulaSim); :}
        | Type:idType ID:id SEMICOLON
            {: RESULT = SemanticHelper.processVarDeclaration(idType, id, null, taulaSim); :}
        ;

Asignacion ::= ID:id EQUAL Valor:valor SEMICOLON
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "=", taulaSim); :}
            | ID:id PLUS_IGUAL Valor:valor SEMICOLON 
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "+=", taulaSim); :}
            | ID:id MENOS_IGUAL Valor:valor SEMICOLON 
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "-=", taulaSim); :}
            | ID:id TIMES_IGUAL Valor:valor SEMICOLON 
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "*=", taulaSim); :}
            | ID:id DIVIDE_IGUAL Valor:valor SEMICOLON 
                {: RESULT = SemanticHelper.processAsignacion(id, valor, "/=", taulaSim); :}
            ;

DecTupla ::= TUPLA ID:id LPAREN TipoLista:tipos RPAREN EQUAL LPAREN ValorLista:valores RPAREN SEMICOLON
                {: RESULT = SemanticHelper.processTuplaDeclaration(id, (STipoLista) tipos, (SValorLista) valores, taulaSim); :}
            ;

TipoLista ::= TipoLista:lista COMMA Type:idType
                {:
                    // Agregamos el tipo subyacente de `idType` a `lista`
                    ((STipoLista) lista).addTipo(((SType) idType).getTipo());
                    RESULT = lista;
                :}
            | Type:idType
                {:
                    // Creamos un nuevo `STipoLista` y a√±adimos el tipo subyacente de `idType`
                    STipoLista lista = new STipoLista();
                    lista.addTipo(((SType) idType).getTipo());
                    RESULT = lista;
                :}
            ;

ValorLista ::= ValorLista:lista COMMA Valor:valor
                {:
                    ((SValorLista) lista).addValor((SValor) valor);
                    RESULT = lista;
                :}
            | Valor:valor
                {:
                    SValorLista lista = new SValorLista();
                    lista.addValor((SValor) valor);
                    RESULT = lista;
                :}
            ;


Type ::= INT     {: RESULT = new SType(new TipoSubyacente(Tipus.INT)); :}
       | FLOAT   {: RESULT = new SType(new TipoSubyacente(Tipus.FLOAT)); :}
       | BOOL    {: RESULT = new SType(new TipoSubyacente(Tipus.BOOLEAN)); :}
       | STRING  {: RESULT = new SType(new TipoSubyacente(Tipus.CHAR)); :}
       ;

Valor ::= INT_LITERAL:v
          {: RESULT = new SValor(new TipoSubyacente(Tipus.INT), v); :}
        | FLOAT_LITERAL:v
          {: RESULT = new SValor(new TipoSubyacente(Tipus.FLOAT), v); :}
        | STRING_LITERAL:v
          {: RESULT = new SValor(new TipoSubyacente(Tipus.CHAR), v); :}
        ;
