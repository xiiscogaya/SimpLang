package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;
import compiler.codigo_intermedio.*;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 
    public static CodigoIntermedio codigoIntermedio = new CodigoIntermedio();

    public static ComplexSymbolFactory factory = new ComplexSymbolFactory();

    public int getLine(Symbol cur_token) {
        ComplexSymbol token = (ComplexSymbol) cur_token;
        Location l = token.getLeft();
        return l.getLine();
        
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        String mensaje = "Error sintáctico en línea " + getLine(cur_token) +
                     ": se encontró '" + (cur_token.value != null ? cur_token.value : cur_token.sym) + "'";
        ErrorManager.addError(2, mensaje);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        String mensaje = "Error sintáctico no recuperable en línea " + getLine(cur_token) +
                        ": se encontró '" + (cur_token.value != null ? cur_token.value : cur_token.sym) + "'";
        
        ErrorManager.addError(2, mensaje); // 2 indica error sintáctico

        // Detener el análisis sintáctico
        done_parsing();
    }
:}

terminal String ID;
terminal String STRING_LITERAL;
terminal FLOAT_LITERAL, INT_LITERAL;
terminal INT, STRING, BOOL, FLOAT, VOID, BOOLEAN_LITERAL;
terminal CONST;
terminal SEMICOLON;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, OP_ASSIGN, EQUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA, ARRAY, DEF, RETURN, OP_ARITMETICO, OP_LOGICO, OP_COMPARACION;
terminal IF, ELIF, ELSE, WHILE, FOR, DOT, PRINT, INPUT;

non terminal Programa, ProgramaList, Main, Sentencia, DecConstante, Valor, Type;
non terminal DecVar, Asignacion, DecTupla, ListaParametros, DecArray, ListaDimensiones;
non terminal DecFun, Bloque, LlamadaFuncion, ListaArgumentos;
non terminal Return, Expresion, ListaTupla, If_Sentencia, Elif_Lista, While_Sentencia;
non terminal For_Sentencia, LlamadaArray, LlamadaTupla, Print_Sentencia, Input_Sentencia, ListaExpresiones;

precedence left OP_ARITMETICO;
precedence left OP_LOGICO;
precedence left OP_COMPARACION;

Programa ::= ProgramaList
            ;

ProgramaList ::= DecFun ProgramaList
            | Main
            ;
Main ::= LBRACE Bloque:bloque RBRACE 
            {: SemanticHelper.procesarMain((SBloque) bloque, taulaSim, codigoIntermedio); :}
        | error RBRACE
        ;

Bloque ::= Sentencia:sentencia Bloque:bloque
            {: RESULT = new SBloque((SBloque) bloque, (SBase) sentencia); :}
        | Sentencia:sentencia
            {: RESULT = new SBloque((SBase) sentencia); :}
            ;

Sentencia ::= DecConstante:s SEMICOLON      {: RESULT = s; :}
            | DecVar:s SEMICOLON            {: RESULT = s; :}
            | DecArray:s SEMICOLON          {: RESULT = s; :}
            | DecTupla:s SEMICOLON          {: RESULT = s; :}
            | Asignacion:s SEMICOLON        {: RESULT = s; :}
            | LlamadaFuncion:s SEMICOLON    {: RESULT = s; :}
            | Return:s SEMICOLON            {: RESULT = s; :}
            | If_Sentencia:s                {: RESULT = s; :}
            | While_Sentencia:s             {: RESULT = s; :}
            | For_Sentencia:s               {: RESULT = s; :}
            | Print_Sentencia:s SEMICOLON   {: RESULT = s; :}
            | Input_Sentencia:s SEMICOLON   {: RESULT = s; :}
            | error SEMICOLON
            ;

DecConstante ::= CONST Type:idType ID:id EQUAL Valor:valor 
                    {: RESULT = new SDecConstante((SType) idType, id, (SValor) valor); :}
                ;

DecVar ::= Type:idType ID:id EQUAL Expresion:e 
            {: RESULT = new SDecVar((SType) idType, id, (SExpresion) e); :}
        | Type:idType ID:id 
            {: RESULT = new SDecVar((SType) idType, id, null); :}
        ;

DecArray ::= ARRAY Type:idType ID:id ListaDimensiones:lista
                {: RESULT = new SDecArray((SType) idType, id, (SListaDimensiones) lista); :}
            ;

DecTupla ::= TUPLA ID:id EQUAL LPAREN ListaTupla:lista RPAREN
                {: RESULT = new SDecTupla(id, (SListaTupla) lista); :}
            ;

ListaTupla ::= DecVar:var COMMA ListaTupla:lista
                {: RESULT = new SListaTupla((SListaTupla) lista, (SDecVar) var); :}
            | DecVar:var
                {: RESULT = new SListaTupla((SDecVar) var); :}
            ;

ListaDimensiones ::= LBRACKET Valor:size RBRACKET ListaDimensiones:lista
                    {: RESULT = new SListaDimensiones((SValor) size, (SListaDimensiones) lista); :}
                | LBRACKET Valor:size RBRACKET
                    {: RESULT = new SListaDimensiones((SValor) size, null); :}
                ;

Asignacion ::= ID:id EQUAL Expresion:e 
                {: RESULT = new SAsignacion(id, "=", (SExpresion) e); :}
            | ID:id OP_ASSIGN:op Expresion:e 
                {: RESULT = new SAsignacion(id, (String) op, (SExpresion) e); :}
            | LlamadaArray:array EQUAL Expresion:e
                {: RESULT = new SAsignacion((SLlamadaArray) array, "=", (SExpresion) e); :}
            ;

ListaParametros ::= Type:idType ID:id COMMA ListaParametros:lista  
                        {: RESULT = new SListaParametros((SType) idType, id, (SListaParametros) lista); :}
                    | Type:idType ID:id
                        {: RESULT = new SListaParametros((SType) idType, id); :}
                    ;

DecFun ::= DEF Type:idType ID:id LPAREN ListaParametros:params RPAREN LBRACE Bloque:bloque RBRACE
                {: SemanticHelper.procesarDecFuncion((SType) idType, id, (SListaParametros) params, (SBloque) bloque, taulaSim, codigoIntermedio); :}
            | error RBRACE 
            ;

LlamadaFuncion ::= ID:id LPAREN ListaArgumentos:lista RPAREN 
                {: 
                    TipoSubyacente tipoRetorno = SemanticHelper.obtenerTipoFuncion(id, taulaSim);
                    RESULT = new SLlamadaFuncion(id, (SListaArgumentos) lista, tipoRetorno); 
                :}
                ;
LlamadaArray ::= ID:id ListaDimensiones:lista
                    {: RESULT = new SLlamadaArray(id, (SListaDimensiones) lista); :}
                ;

LlamadaTupla ::= ID:id DOT ID:campo
                    {: RESULT = new SLlamadaTupla(id, campo); :}
                ;

ListaArgumentos ::= ListaArgumentos:lista COMMA Expresion:e
                    {: RESULT = new SListaArgumentos((SListaArgumentos) lista, (SExpresion) e); :}
                | Expresion:e
                    {: RESULT = new SListaArgumentos((SExpresion) e); :}
                ;

If_Sentencia ::= IF Expresion:expresion LBRACE Bloque:bloque1 RBRACE Elif_Lista:lista ELSE LBRACE Bloque:bloque2 RBRACE
                    {: RESULT = new SIf((SExpresion) expresion, (SBloque) bloque1, (SElif) lista, (SBloque) bloque2); :}
                | IF Expresion:expresion LBRACE Bloque:bloque1 RBRACE Elif_Lista:lista
                    {: RESULT = new SIf((SExpresion) expresion, (SBloque) bloque1, (SElif) lista, null); :}
                | IF Expresion:expresion LBRACE Bloque:bloque1 RBRACE ELSE LBRACE Bloque:bloque2 RBRACE
                    {: RESULT = new SIf((SExpresion) expresion, (SBloque) bloque1, null, (SBloque) bloque2); :}
                | IF Expresion:expresion LBRACE Bloque:bloque1 RBRACE
                    {: RESULT = new SIf((SExpresion) expresion, (SBloque) bloque1, null, null); :}
                ;

Elif_Lista ::= ELIF Expresion:expresion LBRACE Bloque:bloque RBRACE Elif_Lista:lista
                    {: RESULT = new SElif((SElif) lista, (SExpresion) expresion, (SBloque) bloque); :}
                | ELIF Expresion:expresion LBRACE Bloque:bloque RBRACE
                    {: RESULT = new SElif((SExpresion) expresion, (SBloque) bloque); :}
                ;

While_Sentencia ::= WHILE Expresion:expresion LBRACE Bloque:bloque RBRACE
                    {: RESULT = new SWhile((SExpresion) expresion, (SBloque) bloque); :}
                ;

For_Sentencia ::= FOR LPAREN DecVar:init SEMICOLON Expresion:condicion SEMICOLON Asignacion: actuali RPAREN LBRACE Bloque:bloque RBRACE
                    {: RESULT = new SFor((SDecVar) init, (SExpresion) condicion, (SAsignacion) actuali, (SBloque) bloque); :}
                ;

Print_Sentencia ::= PRINT LPAREN ListaExpresiones:lista RPAREN
                        {: RESULT = new SPrint((SListaExpresiones) lista); :}
                    ;

Input_Sentencia ::= INPUT LPAREN ID:id RPAREN
                        {: RESULT = new SInput(id); :}
                    ;

ListaExpresiones ::= Expresion:e COMMA ListaExpresiones:lista
                        {: RESULT = new SListaExpresiones((SListaExpresiones) lista, (SExpresion) e); :}
                    | Expresion:e
                        {: RESULT = new SListaExpresiones((SExpresion) e); :}
                    ;

Return ::= RETURN Expresion:expresion 
            {: RESULT = new SReturn((SExpresion) expresion); :}
        | RETURN 
            {: RESULT = new SReturn(); :}
        ;

Type ::= INT     {: RESULT = new SType(new TipoSubyacente(Tipus.INT)); :}
       | FLOAT   {: RESULT = new SType(new TipoSubyacente(Tipus.FLOAT)); :}
       | BOOL    {: RESULT = new SType(new TipoSubyacente(Tipus.BOOLEAN)); :}
       | STRING  {: RESULT = new SType(new TipoSubyacente(Tipus.STRING)); :}
       | VOID    {: RESULT = new SType(new TipoSubyacente(Tipus.VOID)); :}
       ;

Expresion ::= Expresion:e1 OP_ARITMETICO:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_LOGICO:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | Expresion:e1 OP_COMPARACION:op Expresion:e2
                {: RESULT = new SExpresion((SExpresion) e1, (SExpresion) e2, (String) op); :}
            | LlamadaFuncion:func
                {: RESULT = new SExpresion((SLlamadaFuncion) func); :}
            | LlamadaArray:array
                {: RESULT = new SExpresion((SLlamadaArray) array); :}
            | LlamadaTupla:tupla
                {: RESULT = new SExpresion((SLlamadaTupla) tupla); :}
            | LPAREN Expresion:e RPAREN
                {: RESULT = e; :}
            | Valor:valor
                {: RESULT = new SExpresion((SValor) valor); :}
            | ID:id
                {: RESULT = new SExpresion((String) id); :}
            ;

Valor ::= INT_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.INT), (String) v); :}
        | FLOAT_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.FLOAT), (String) v); :}
        | STRING_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.STRING), (String) v); :}
        | BOOLEAN_LITERAL:v
            {: RESULT = new SValor(new TipoSubyacente(Tipus.BOOLEAN), (String) v); :}
        ;

