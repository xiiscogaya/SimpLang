package compiler.sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;

import compiler.simbols.*;
import compiler.taulasimbols.*;

import java.io.PrintStream;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;


class Parser;

parser code {:

    public static TaulaSimbols taulaSim = new TaulaSimbols(); 

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Error sintactic", cur_token);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_error("Error sintactico no recuperable", cur_token);
        done_parsing();
    }

    @Override
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line " + (s.left + 1));   
                if (s.right >= 0)
                    m.append(", column " + (s.right + 1));
            }
        }
        m.append(" : " + message);
        System.err.println(m);
    }
:}

terminal String ID;
terminal VALOR;
terminal String STRING_LITERAL;
terminal INT, STRING, BOOL, FLOAT, VOID, BOOLEAN_LITERAL;
terminal CONST, SEMICOLON;
terminal LBRACE, RBRACE, LBRACKET, RBRACKET, OP_ASSIGN, EQUAL;
terminal TUPLA, LPAREN, RPAREN, COMMA, ARRAY, DEF, CLASS, RETURN, OP_ARITMETICO;

non terminal Programa, ProgramaList, DecList, Main, Sentencia, DecConstante, Valor, Type;
non terminal DecVar, Asignacion, DecTupla, ListaParametros, DecArray, ListaDimensiones;
non terminal DecFun, DecClass, ClassMemberList, ClassMember, Bloque, LlamadaFuncion, ListaArgumentos;
non terminal Return, Expresion;

Programa ::= ProgramaList
            ;

ProgramaList ::= DecList ProgramaList
            | LBRACE Main RBRACE 
                ;


DecList ::= DecFun 
            | DecClass 
            | error RBRACE
            ;

Main ::= Main Sentencia
        | Sentencia
        ;

Bloque ::= Bloque:bloque Sentencia:sentencia
            {: 
                ((SBloque) bloque).addSentencia((SBase) sentencia);
                RESULT = bloque;
            :}
        | Sentencia:sentencia
            {:
                SBloque bloque = new SBloque();
                bloque.addSentencia((SBase) sentencia);
                RESULT = bloque;
            :}
            ;

Sentencia ::= DecConstante:s    {: RESULT = s; :}
            | DecVar:s          {: RESULT = s; :}
            | Asignacion:s      {: RESULT = s; :}
            | LlamadaFuncion:s    {: RESULT = s; :}
            | Return:s            {: RESULT = s; :}
            ;

DecConstante ::= CONST Type:idType ID:id EQUAL Valor:valor SEMICOLON
                    {: RESULT = new SDecConstante((SType) idType, id, (SValor) valor); :}
                ;

DecVar ::= Type:idType ID:id EQUAL Expresion:e SEMICOLON
            {: RESULT = new SDecVar((SType) idType, id, (SExpresion) e); :}
        | Type:idType ID:id SEMICOLON
            {: RESULT = new SDecVar((SType) idType, id, null); :}
        ;

Asignacion ::= ID:id EQUAL Expresion:e SEMICOLON
                {: RESULT = new SAsignacion(id, (SExpresion) e); :}
            | ID:id OP_ASSIGN:op Expresion:e SEMICOLON
                {: RESULT = new SAsignacion(id, (SExpresion) e); :}
            ;

ListaParametros ::= ListaParametros:lista COMMA Type:idType ID:id
                        {: RESULT = SemanticHelper.procesarListaParametros((SListaParametros) lista, (SType) idType, id, taulaSim); :}
                    | Type:idType ID:id
                        {: RESULT = SemanticHelper.procesarListaParametros(null, (SType) idType, id, taulaSim); :}
                    ;

DecFun ::= DEF Type:idType ID:id LPAREN ListaParametros:params RPAREN LBRACE Bloque:bloque RBRACE
            {: SemanticHelper.procesarDecFuncion((SType) idType, id, (SListaParametros) params, (SBloque) bloque, taulaSim); :}
            ;

LlamadaFuncion ::= ID:id LPAREN ListaArgumentos:lista RPAREN SEMICOLON
                {: 
                    TipoSubyacente tipoRetorno = SemanticHelper.obtenerTipoFuncion(id, taulaSim);
                    RESULT = new SLlamadaFuncion(id, (SListaArgumentos) lista, tipoRetorno); 
                :}
                ;

ListaArgumentos ::= ListaArgumentos:lista COMMA Valor:valor
                    {: RESULT = SemanticHelper.procesarListaArgumentos((SListaArgumentos) lista, (SValor) valor, taulaSim); :}
                | Valor:valor
                    {: RESULT = SemanticHelper.procesarListaArgumentos(null, (SValor) valor, taulaSim); :}
                ;

Return ::= RETURN Valor:valor SEMICOLON
            {: RESULT = new SReturn((SValor) valor); :}
        | RETURN SEMICOLON
            {: RESULT = new SReturn(); :}
        ;

Type ::= INT     {: RESULT = new SType(new TipoSubyacente(Tipus.INT)); :}
       | FLOAT   {: RESULT = new SType(new TipoSubyacente(Tipus.FLOAT)); :}
       | BOOL    {: RESULT = new SType(new TipoSubyacente(Tipus.BOOLEAN)); :}
       | STRING  {: RESULT = new SType(new TipoSubyacente(Tipus.STRING)); :}
       | VOID    {: RESULT = new SType(new TipoSubyacente(Tipus.VOID)); :}
       ;

Expresion ::= Expresion:e1 OP_ARITMETICO:op Expresion:e2
                {: RESULT = SemanticHelper.procesarExpresion((SExpresion) e1, (String) op, (SExpresion) e2, taulaSim); :}
            | LlamadaFuncion:func
                {: RESULT = new SExpresion(((SLlamadaFuncion) func).getTipoRetorno()):}
            | LPAREN Expresion:e RPAREN
                {: RESULT = e; :}
            | Valor:v
                {: RESULT = new SExpresion(((SValor) v).getTipo()):}
            ;

Valor ::= VALOR:v
            {: 
                // Detectar si es entero o flotante seg√∫n la presencia del punto decimal
                if (((String) v).contains(".")) {
                    RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.FLOAT), v);
                } else {
                    RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.INT), v);
                }
            :}
        | STRING_LITERAL:v
            {: RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.STRING), v); :}
        | BOOLEAN_LITERAL:v
            {: RESULT = SemanticHelper.crearValorConComprobacion(new TipoSubyacente(Tipus.BOOLEAN), v); :}
        | ID:id
            {: RESULT = SemanticHelper.crearValorConComprobacion(null, id); :}
        ;

